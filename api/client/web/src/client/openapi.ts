/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/v1/events': {
    /**
     * List ingested events
     * @description List ingested events within a time range.
     */
    get: operations['listEvents']
    /**
     * Ingest events
     * @description Ingests an event or batch of events following the CloudEvents specification.
     */
    post: operations['ingestEvents']
  }
  '/api/v1/meters': {
    /**
     * List meters
     * @description List meters.
     */
    get: operations['listMeters']
    /**
     * ☁ Create meter
     * @description *Available in OpenMeter Cloud.*
     * *In the open-source version, meters are created in the configuration file.*
     *
     * Create a meter.
     */
    post: operations['createMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}': {
    /**
     * Get meter
     * @description Get meter by ID or slug
     */
    get: operations['getMeter']
    /**
     * ☁ Delete meter
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a meter by ID or slug.
     */
    delete: operations['deleteMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/query': {
    /**
     * Query meter
     * @description Query meter for usage.
     */
    get: operations['queryMeter']
  }
  '/api/v1/meters/{meterIdOrSlug}/subjects': {
    /**
     * List meter subjects
     * @description List subjects for a meter.
     */
    get: operations['listMeterSubjects']
  }
  '/api/v1/portal/tokens': {
    /**
     * ☁ List portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * List consumer portal tokens.
     */
    get: operations['listPortalTokens']
    /**
     * Create portal token
     * @description Create a consumer portal token.
     */
    post: operations['createPortalToken']
  }
  '/api/v1/portal/tokens/invalidate': {
    /**
     * ☁ Invalidate portal tokens
     * @description *Available in OpenMeter Cloud.*
     *
     * Invalidates consumer portal tokens by ID or subject.
     */
    post: operations['invalidatePortalTokens']
  }
  '/api/v1/subjects': {
    /**
     * ☁ List subjects
     * @description *Available in OpenMeter Cloud.*
     *
     * List subjects.
     */
    get: operations['listSubjects']
    /**
     * ☁ Upsert subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Upserts a subject. Creates or updates subject.
     * If the subject doesn't exist, it will be created.
     * If the subject exists, it will be partially updated with the provided fields.
     */
    post: operations['upsertSubject']
  }
  '/api/v1/subjects/{subjectIdOrKey}': {
    /**
     * ☁ Get subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Get subject by ID or key.
     */
    get: operations['getSubject']
    /**
     * ☁ Delete subject
     * @description *Available in OpenMeter Cloud.*
     *
     * Delete a subject by ID or key.
     */
    delete: operations['deleteSubject']
  }
  '/api/v1/portal/meters/{meterSlug}/query': {
    /**
     * Query portal meter
     * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
     */
    get: operations['queryPortalMeter']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    /**
     * @description A Problem Details object (RFC 7807).
     * Additional properties specific to the problem type may be present.
     * @example {
     *   "type": "urn:problem-type:bad-request",
     *   "title": "Bad Request",
     *   "status": 400,
     *   "detail": "body must be a JSON object"
     * }
     */
    Problem: {
      /**
       * Format: uri
       * @description Type contains a URI that identifies the problem type.
       * @example urn:problem-type:bad-request
       */
      type: string
      /**
       * @description A a short, human-readable summary of the problem type.
       * @example Bad Request
       */
      title: string
      /**
       * Format: int32
       * @description The HTTP status code generated by the origin server for this occurrence of the problem.
       * @example 400
       */
      status: number
      /**
       * @description A human-readable explanation specific to this occurrence of the problem.
       * @example body must be a JSON object
       */
      detail: string
      /**
       * Format: uri
       * @description A URI reference that identifies the specific occurrence of the problem.
       * @example urn:request:local/JMOlctsKV8-000001
       */
      instance?: string
      [key: string]: unknown
    }
    /**
     * @description CloudEvents Specification JSON Schema
     * @example {
     *   "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3c",
     *   "source": "service-name",
     *   "specversion": "1.0",
     *   "type": "prompt",
     *   "subject": "customer-id",
     *   "time": "2023-01-01T01:01:01.001Z",
     *   "data": {
     *     "tokens": "1234",
     *     "model": "gpt-4-turbo",
     *     "type": "input"
     *   }
     * }
     */
    Event: {
      /**
       * @description Identifies the event.
       * @example 5c10fade-1c9e-4d6c-8275-c52c36731d3c
       */
      id: string
      /**
       * Format: uri-reference
       * @description Identifies the context in which an event happened.
       * @example service-name
       */
      source: string
      /**
       * @description The version of the CloudEvents specification which the event uses.
       * @example 1.0
       */
      specversion: string
      /**
       * @description Describes the type of event related to the originating occurrence.
       * @example prompt
       */
      type: string
      /**
       * @description Content type of the data value. Must adhere to RFC 2046 format.
       * @example application/json
       * @enum {string|null}
       */
      datacontenttype?: 'application/json' | null
      /**
       * Format: uri
       * @description Identifies the schema that data adheres to.
       */
      dataschema?: string | null
      /**
       * @description Describes the subject of the event in the context of the event producer (identified by source).
       * @example customer-id
       */
      subject: string
      /**
       * Format: date-time
       * @description Timestamp of when the occurrence happened. Must adhere to RFC 3339.
       * @example 2023-01-01T01:01:01.001Z
       */
      time?: string | null
      /**
       * @description The event payload.
       * @example {
       *   "tokens": "1234",
       *   "model": "gpt-4-turbo"
       * }
       */
      data?: {
        [key: string]: unknown
      }
    }
    /**
     * @description An ingested event with optional validation error.
     * @example {
     *   "event": {
     *     "id": "5c10fade-1c9e-4d6c-8275-c52c36731d3d",
     *     "source": "service-name",
     *     "specversion": "1.0",
     *     "type": "prompt",
     *     "subject": "customer-id",
     *     "time": "2023-01-01T01:01:01.001Z",
     *     "data": {
     *       "tokens": "1234",
     *       "model": "gpt-4-turbo"
     *     }
     *   },
     *   "validationError": "meter not found for event"
     * }
     */
    IngestedEvent: {
      event: components['schemas']['Event']
      /** @example invalid event */
      validationError?: string
    }
    /**
     * @description A meter is a configuration that defines how to match and aggregate events.
     * @example {
     *   "slug": "tokens_total",
     *   "description": "AI token usage",
     *   "aggregation": "SUM",
     *   "windowSize": "MINUTE",
     *   "eventType": "prompt",
     *   "valueProperty": "$.tokens",
     *   "groupBy": {
     *     "model": "$.model",
     *     "type": "$.type"
     *   }
     * }
     */
    Meter: {
      /**
       * @description A unique identifier for the meter.
       * @example 01G65Z755AFWAKHE12NY0CQ9FH
       */
      id?: string
      /**
       * @description A unique, human-readable identifier for the meter. Must consist only alphanumeric and underscore characters.
       * @example tokens_total
       */
      slug: string
      /**
       * @description A description of the meter.
       * @example AI Token Usage
       */
      description?: string | null
      aggregation: components['schemas']['MeterAggregation']
      windowSize: components['schemas']['WindowSize']
      /**
       * @description The event type to aggregate.
       * @example prompt
       */
      eventType: string
      /**
       * @description JSONPath expression to extract the value from the ingested event's data property.
       * The ingested value for SUM, AVG, MIN, and MAX aggregations is a number or a string that can be parsed to a number.
       * For UNIQUE_COUNT aggregation, the ingested value must be a string. For COUNT aggregation the valueProperty is ignored.
       *
       * @example $.tokens
       */
      valueProperty?: string
      /**
       * @description Named JSONPath expressions to extract the group by values from the event data. Keys must be unique and consist only alphanumeric and underscore characters.
       * @example {
       *   "model": "$.model",
       *   "type": "$.type"
       * }
       */
      groupBy?: {
        [key: string]: string
      }
    }
    /**
     * @description The aggregation type to use for the meter.
     * @example SUM
     * @enum {string}
     */
    MeterAggregation: 'SUM' | 'COUNT' | 'UNIQUE_COUNT' | 'AVG' | 'MIN' | 'MAX'
    /**
     * @description Aggregation window size.
     * @example MINUTE
     * @enum {string}
     */
    WindowSize: 'MINUTE' | 'HOUR' | 'DAY'
    /**
     * @description The result of a meter query.
     * @example {
     *   "from": "2023-01-01T00:00:00Z",
     *   "to": "2023-01-02T00:00:00Z",
     *   "windowSize": "MINUTE",
     *   "data": [
     *     {
     *       "value": 12,
     *       "windowStart": "2023-01-01T00:00:00Z",
     *       "windowEnd": "2023-01-02T00:00:00Z",
     *       "subject": "customer-id",
     *       "groupBy": {
     *         "model": "gpt-4-turbo",
     *         "type": "prompt"
     *       }
     *     }
     *   ]
     * }
     */
    MeterQueryResult: {
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      from?: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      to?: string
      windowSize?: components['schemas']['WindowSize']
      /**
       * @example [
       *   {
       *     "value": 12,
       *     "windowStart": "2023-01-01T00:00:00Z",
       *     "windowEnd": "2023-01-02T00:00:00Z",
       *     "subject": "customer-id",
       *     "groupBy": {
       *       "model": "gpt-4-turbo",
       *       "type": "prompt"
       *     }
       *   }
       * ]
       */
      data: components['schemas']['MeterQueryRow'][]
    }
    /**
     * @description A row in the result of a meter query.
     * @example {
     *   "value": 12,
     *   "windowStart": "2023-01-01T00:00:00Z",
     *   "windowEnd": "2023-01-02T00:00:00Z",
     *   "subject": "customer-id",
     *   "groupBy": {
     *     "model": "gpt-4-turbo",
     *     "type": "prompt"
     *   }
     * }
     */
    MeterQueryRow: {
      /** @example 12 */
      value: number
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      windowStart: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      windowEnd: string
      /**
       * @description The subject of the meter value.
       * @example customer-id
       */
      subject?: string | null
      /**
       * @example {
       *   "model": "gpt-4-turbo",
       *   "type": "prompt"
       * }
       */
      groupBy?: {
        [key: string]: string
      } | null
    }
    /**
     * @description A consumer portal token.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "subject": "customer-id",
     *   "expiresAt": "2023-01-02T00:00:00Z",
     *   "expired": false,
     *   "createdAt": "2023-01-01T00:00:00Z",
     *   "token": "om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo",
     *   "allowedMeterSlugs": [
     *     "tokens_total"
     *   ]
     * }
     */
    PortalToken: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id?: string
      /** @example customer-id */
      subject: string
      /**
       * Format: date-time
       * @example 2023-01-02T00:00:00Z
       */
      expiresAt?: string
      expired?: boolean
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      createdAt?: string
      /**
       * @description The token is only returned at creation.
       * @example om_portal_IAnD3PpWW2A2Wr8m9jfzeHlGX8xmCXwG.y5q4S-AWqFu6qjfaFz0zQq4Ez28RsnyVwJffX5qxMvo
       */
      token?: string
      /**
       * @description Optional, if defined only the specified meters will be allowed
       * @example [
       *   "tokens_total"
       * ]
       */
      allowedMeterSlugs?: string[]
    }
    /**
     * @description A subject is a unique identifier for a user or entity.
     * @example {
     *   "id": "01G65Z755AFWAKHE12NY0CQ9FH",
     *   "key": "customer-id",
     *   "displayName": "Customer Name",
     *   "metadata": {
     *     "hubspotId": "123456"
     *   },
     *   "currentPeriodStart": "2023-01-01T00:00:00Z",
     *   "currentPeriodEnd": "2023-02-01T00:00:00Z",
     *   "stripeCustomerId": "cus_JMOlctsKV8"
     * }
     */
    Subject: {
      /** @example 01G65Z755AFWAKHE12NY0CQ9FH */
      id?: string
      /** @example customer-id */
      key: string
      /** @example Customer Name */
      displayName?: string | null
      /**
       * @example {
       *   "hubspotId": "123456"
       * }
       */
      metadata?: {
        [key: string]: unknown
      } | null
      /**
       * Format: date-time
       * @example 2023-01-01T00:00:00Z
       */
      currentPeriodStart?: string | null
      /**
       * Format: date-time
       * @example 2023-02-01T00:00:00Z
       */
      currentPeriodEnd?: string | null
      /** @example cus_JMOlctsKV8 */
      stripeCustomerId?: string | null
    }
    /**
     * @description A unique identifier.
     * @example tokens_total
     */
    IdOrSlug: string
  }
  responses: {
    /** @description Bad Request */
    BadRequestProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unauthorized */
    UnauthorizedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Not Found */
    NotFoundProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Not Implemented */
    NotImplementedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
    /** @description Unexpected error */
    UnexpectedProblemResponse: {
      content: {
        'application/problem+json': components['schemas']['Problem']
      }
    }
  }
  parameters: {
    /** @description A unique identifier for the meter. */
    meterIdOrSlug: components['schemas']['IdOrSlug']
    /** @description A unique identifier for a subject. */
    subjectIdOrKey: string
    /**
     * @description Start date-time in RFC 3339 format.
     * Inclusive.
     */
    queryFrom?: string
    /**
     * @description End date-time in RFC 3339 format.
     * Inclusive.
     */
    queryTo?: string
    /** @description If not specified, a single usage aggregate will be returned for the entirety of the specified period for each subject and group. */
    queryWindowSize?: components['schemas']['WindowSize']
    /**
     * @description The value is the name of the time zone as defined in the IANA Time Zone Database (http://www.iana.org/time-zones).
     * If not specified, the UTC timezone will be used.
     */
    queryWindowTimeZone?: string
    /**
     * @description Filtering and group by multiple subjects.
     * Usage: ?subject=customer-1&subject=customer-2
     */
    queryFilterSubject?: string[]
    queryFilterGroupBy?: {
      [key: string]: string
    }
    /**
     * @description If not specified a single aggregate will be returned for each subject and time window.
     * `subject` is a reserved group by value.
     */
    queryGroupBy?: string[]
  }
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /**
   * List ingested events
   * @description List ingested events within a time range.
   */
  listEvents: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        /** @description Number of events to return */
        limit?: number
      }
    }
    responses: {
      /** @description List of events for debugging. */
      200: {
        content: {
          'application/json': components['schemas']['IngestedEvent'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Ingest events
   * @description Ingests an event or batch of events following the CloudEvents specification.
   */
  ingestEvents: {
    /**
     * @description The event or batch of events to ingest.
     * The request body must be a CloudEvents JSON object or an array of CloudEvents JSON objects.
     * The CloudEvents JSON object must adhere to the CloudEvents Specification JSON Schema.
     */
    requestBody: {
      content: {
        'application/cloudevents+json': components['schemas']['Event']
        'application/cloudevents-batch+json': components['schemas']['Event'][]
      }
    }
    responses: {
      /** @description Successfully ingested. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meters
   * @description List meters.
   */
  listMeters: {
    responses: {
      /** @description List of meters. */
      200: {
        content: {
          'application/json': components['schemas']['Meter'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Create meter
   * @description *Available in OpenMeter Cloud.*
   * *In the open-source version, meters are created in the configuration file.*
   *
   * Create a meter.
   */
  createMeter: {
    /** @description The meter to create. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Meter']
      }
    }
    responses: {
      /** @description Created. */
      201: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Get meter
   * @description Get meter by ID or slug
   */
  getMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter found. */
      200: {
        content: {
          'application/json': components['schemas']['Meter']
        }
      }
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete meter
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a meter by ID or slug.
   */
  deleteMeter: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Meter deleted. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query meter
   * @description Query meter for usage.
   */
  queryMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        subject?: components['parameters']['queryFilterSubject']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * List meter subjects
   * @description List subjects for a meter.
   */
  listMeterSubjects: {
    parameters: {
      path: {
        meterIdOrSlug: components['parameters']['meterIdOrSlug']
      }
    }
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': string[]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * List consumer portal tokens.
   */
  listPortalTokens: {
    parameters: {
      query?: {
        /** @description Number of portal tokens to return. Default is 25. */
        limit?: number
      }
    }
    responses: {
      /** @description List of portal tokens. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Create portal token
   * @description Create a consumer portal token.
   */
  createPortalToken: {
    /** @description The portal token to create. */
    requestBody: {
      content: {
        /**
         * @example {
         *   "subject": "customer-id",
         *   "allowedMeterSlugs": [
         *     "tokens_total"
         *   ]
         * }
         */
        'application/json': components['schemas']['PortalToken']
      }
    }
    responses: {
      /** @description Created. */
      200: {
        content: {
          'application/json': components['schemas']['PortalToken']
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Invalidate portal tokens
   * @description *Available in OpenMeter Cloud.*
   *
   * Invalidates consumer portal tokens by ID or subject.
   */
  invalidatePortalTokens: {
    /** @description If no id or subject is specified, all tokens will be invalidated. */
    requestBody: {
      content: {
        'application/json': {
          /** @description Invalidate a portal token by ID. */
          id?: string
          /** @description Invalidate all portal tokens for a subject. */
          subject?: string
        }
      }
    }
    responses: {
      /** @description Portal tokens invalidated. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ List subjects
   * @description *Available in OpenMeter Cloud.*
   *
   * List subjects.
   */
  listSubjects: {
    responses: {
      /** @description List of subjects. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Upsert subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Upserts a subject. Creates or updates subject.
   * If the subject doesn't exist, it will be created.
   * If the subject exists, it will be partially updated with the provided fields.
   */
  upsertSubject: {
    /** @description The subject to upsert. */
    requestBody: {
      content: {
        'application/json': components['schemas']['Subject'][]
      }
    }
    responses: {
      /** @description Subject upserted. */
      200: {
        content: {
          'application/json': components['schemas']['Subject'][]
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Get subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Get subject by ID or key.
   */
  getSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject found. */
      200: {
        content: {
          'application/json': components['schemas']['Subject']
        }
      }
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * ☁ Delete subject
   * @description *Available in OpenMeter Cloud.*
   *
   * Delete a subject by ID or key.
   */
  deleteSubject: {
    parameters: {
      path: {
        subjectIdOrKey: components['parameters']['subjectIdOrKey']
      }
    }
    responses: {
      /** @description Subject deleted. */
      204: {
        content: never
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      404: components['responses']['NotFoundProblemResponse']
      501: components['responses']['NotImplementedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
  /**
   * Query portal meter
   * @description Query meter for consumer portal. This endpoint is publicly exposable to consumers.
   */
  queryPortalMeter: {
    parameters: {
      query?: {
        from?: components['parameters']['queryFrom']
        to?: components['parameters']['queryTo']
        windowSize?: components['parameters']['queryWindowSize']
        windowTimeZone?: components['parameters']['queryWindowTimeZone']
        filterGroupBy?: components['parameters']['queryFilterGroupBy']
        groupBy?: components['parameters']['queryGroupBy']
      }
      path: {
        /** @description A unique identifier for the meter. */
        meterSlug: string
      }
    }
    responses: {
      /** @description Usage data. */
      200: {
        content: {
          'application/json': components['schemas']['MeterQueryResult']
          'text/csv': string
        }
      }
      400: components['responses']['BadRequestProblemResponse']
      401: components['responses']['UnauthorizedProblemResponse']
      default: components['responses']['UnexpectedProblemResponse']
    }
  }
}
